## React??
React는 UI 컴포넌트 라이브러리

React UI 컴포넌트는 매우 독립적이며 관심사에 집중된 기능 블록이다.
ex) 날짜, 날씨, 주소 ...

컴포넌트 기반 아키텍쳐를 사용하기에 일반적으로 일체형 UI에 비해 **재사용성** 과 **유지보수**, **확장** 에 좋다.

## React의 장점

첫 번째는 **간결성**이다.

React를 간결하게 만들어주는 것들은
```
선언형 스타일 채택

순수한 자바스크립트를 이용한 컴포넌트 기반 아키텍쳐

강력한 추상화
```
이렇게 총 세가지 있다.

먼저 명령형 스타일과는 달리 **선언형 스타일**을 채택하여 복잡도를 줄이고 코드에 대한 이해도와 가독성을 높였다.

```
선언형 스타일
var arr = [1,2,3,4,5],
  arr2 = []
for( var i = 0; i<arr.length; i++ ){
  arr2[i] = arr[i]*2
}
console.log('a', arr2)

명령형 스타일
var arr = [1,2,3,4,5],
  arr2 = arr.map(function(v,i){ return v*2 })
console.log('b', arr2)
```
```
출력 : [2,4,6,8,10]
```
React에서는 개발자가 UI 요소를 선언형 스타일로 작성하면 자동으로 DOM을 갱신한다.

바로 이러한 **내부 상태 변화** 로 인해 DOM이 갱신 될 때 선언형 스타일이 빛을 발한다.

React는 DOM에 대한 변화가 생길때 내부적으로 **가상DOM**을 사용하여 이미 반영된 DOM과 새로운 DOM의 차이점을 찾아낸다.

따라서 개발자가 명시적으로 DOM을 변경 할 필요가 없다.

하지만 JQuerry를 사용한다면 이러한 갱신 과정을 명령형으로 작성해야 한다.


### 여기서 DOM이란??
DOM은 문서 객체 모델(Document Object Model)로서 XML이나 HTML 문서에 접근하기 위한 일종의 인터페이스이며

자바스크립트를 활용하여 문서 내의 모든 요소(element)를 정의하고, 각각의 요소에 접근하는 방법을 제공한다.

여기서 문서(document)란 웹 페이지를 의미한다.

즉,웹 페이지를 이루는 태그들을 자바스크립트로 접근 할 수 있게끔 브라우저가 **트리구조**로 만든 객체 모델이다.

![dom-tree](https://user-images.githubusercontent.com/81299056/126020230-10737b72-2ef9-4b98-97ef-f6b9aad9b016.png)

1. 문서노드 : 트리의 루트에 존재하며, 다른 노드들에 접근 시 이 문서노드를 통과해야 한다.
2. 요소노드 : 요소 노드는 HTML요소를 표현하기에 문서의 구조를 서술 한다 
3. 어트리뷰트 노드 : HTML요소의 어트리뷰트 표현, 어트리뷰트 노드는 해당 어트리뷰트가 지정된 요소의 일부로 표현된다.
4. 텍스트 노드 : 텍스트 노드는 요소 노드의 자식이며 리프노드이다.

### 가상 DOM이 왜 필요할까?
브라우저의 작동 원리를 보면
```
브라우저가 HTML을 전달받으면, 브라우저의 렌더엔진이 이를 파싱하고 앞서 언급한 DOM 트리를 만든다.

그리고 외부 CSS파일이나 각 엘리먼트의 inline 스타일을 파싱하여 렌더트리를 만든다.

여기서 렌더트리 생성때는 노드의 스타일을 처리하는데, 이때 각 노드들은 attach라는 메소드를 통해 스타일정보를 계산하여 객체형태로 반환한다.

이러한 렌더트리 생성이 끝나게 되면, 레이아웃 과정을 거치게 되는데, 이때는 각 노드들이 어디에 위치하여야 하는지 정해진다.

마지막으로 페인팅 과정을 통해 트리의 각 노드들을 거쳐가면서 요소들에 색을 입힌다.
```
이러한 과정을 볼 수 있는데, 만약 DOM을 수정 하거나 조작 했을 시 문제가 발생한다.

DOM에 대한 변화가 생기는 경우 또 렌더트리를 만들고 각 레이아웃과정 및 페인팅 과정이 반복되게 되는데, 

**이러한 반복이 결국 메모리 낭비를 띄게 된다.**

그리하여 

실제 DOM을 조작하는 것 대신, 이것을 추상화 시킨 자바스크립트 객체를 이용한다. 

바로 이것이 가상 DOM

### 그러면 어떻게 가상DOM이 쓰이는데?

가상 DOM의 작동방식은 다음과 같다

```
1. 데이터를 업데이트 하면 전체 UI를 가상돔에 리렌더링 한다.

2. 이전 가상돔에 있던 내용과 현재 내용을 비교한다. (Diff 알고리즘)

3. 바뀐 부분만 실제 DOM에 적용한다.
```

#### 여기서 간단하게 알아보는 비교 알고리즘(Diffing Algorithm)

가상 DOM의 작동방식에서 "2. 이전 가상돔에 있던 내용과 현재 내용을 비교한다." 는 **비교 알고리즘**에 의해 재조정된다.

루트 엘리먼트부터 비교하여 이후의 동작은 루트 엘리먼트의 타입에 따라 달라진다.

```
1. 루트 엘리먼트의 타입이 다른경우

React는 이전 트리를 버리고 완전히 새로운 트리를 구축해버린다.

2. 같은 타입의 DOM 엘리먼트 인 경우

두 엘리먼트의 속성에 대한 변경이 있을 경우 갱신한다.

3. 자식에 대한 재귀적 처리

DOM 노드들의 자식들은 부모 노드의 변화가 있을 경우 재귀적으로 처리 되며

이 때 React는 기본적으로 동시에 두 리스트를 순회하고 차이점이 있으면 변경한다.

```
**결국 가상DOM은 실제로 렌더링 되지도 않기 때문에 연산비용도 적고, 최종적인 변화만 실제 DOM에 던져 준다.**      
***

간결성을 도와주는 두 번째 요소인 **순수한 자바스크립트를 이용한 컴포넌트 기반 아키텍쳐** 에서 

**컴포넌트 기반 아키텍쳐**는 이미 React 이전에도 **관심사 분리, 느슨한 결합, 코드 재사용이 쉬움** 으로 인해 

소프트웨어 엔지니어들이 좋아하는 아키텍쳐 이다.

특히 React의 컴포넌트 클래스는 이런 컴포넌트 기반 아키텍쳐를 구성하는 블록으로

위의 컴포넌트 기반 아키텍쳐의 이점들 중 **코드 재사용**이 가장 잘 보이는 기능이다.

그기에다가 **순수한 자바스크립트로 구현한 컴포넌트 기반 아키텍쳐는 React 이전에는 없었다!!!**

***
간결성을 도와주는 마지막 요소인 **강력한 추상화**는 내부의 인터페이스는 숨기고, 정규화 과정을 거친 합성 메서드와 속성을 제공한다.

결국 브라우저의 종류와 상관없이 항상 같은 객체를 전달 받으며 터치 이벤트에 대해서도 동일하게 제공하므로 

모바일 기기를 대응한 웹 앱을 만들 때도 유용하다.

또한 서버 측 렌더링 기능을 통해 검색 엔진 최적화와 성능 개선에도 유용하다.

***
두 번째 React의 장점으로 **속도와 테스트의 용이성** 이다.

앞서 설명과 더불어 가상 DOM은 자바스크립트 메모리 상에만 존재하고 불필요한 메모리 낭비는 줄이므로, 속도면에서 좀 더 뛰어나며

테스트 하는데 있어서 헤드리스 브라우저 없이도 단위 테스트를 수행 할 수 있다.

## 단일 페이지 애플리케이션과 React

먼저 **단일 페이지 애플리케이션 (SPA : Single Page applications) 아키텍처**에 대해 알아보자

### SPA??

SPA 아키텍처는 서버보다는 클라이언트, 즉 브라우저 측에 로직이 더 많은 **팻 클라이언트 (혹은 thick client) 이다.**

그러므로 SPA는 HTML 렌더링, 입력값 검증, UI 변경 등의 기능을 브라우저에서 해결한다.

다음은 일반적인 SPA 아키텍처의 동작 과정이다.

```
1. 사용자가 새로운 페이지를 열기 위해 브라우저에 URL을 입력한다.

2. 브라우저가 URL 요청을 서버로 전송한다.

3. 서버는 응답으로 HTML, CSS, 자바스크립트 파일과 같은 정적자원을 보낸다. 

  HTML의 경우 최소한의 기본 구조만 담고 있다.
  
  자바 스크립트의 경우 SPA를 위한 자원으로 쓰인다.
  
  이 단계 에서는 보통 "로딩 중..." 과 같은 메시지를 통해 페이지가 준비 중이라는 것을 나타낸다

4. 자바 스크립트 로드 후 추가로 AJAX 나 XHR 요청을 보내 서버에서 데이터를 불러온다.

  여기서 데이터는 JSON이나 XML 형태로 받는다.
  
5. AJAX나 XHR의 결과로 데이터가 SPA로 오면 템플릿에 데이터를 밀어 넣고 브라우저상에 UI를 렌더링한다.

  여기서 렌더링이 끝나게 되면 "로딩 중..." 과 같은 메시지가 사라지고 사용 가능한 상태가 된다.
  
6. 사용자가 웹 페이지를 확인하며 서버로 새로운 요청을 발생 시키기도 하고, 브라우저 라우팅이 이뤄지기도 한다.

  특히 브라우저 라우팅 때는 새로운 페이지를 로딩하지 않고 브라우저에서 다시 렌더링을 수행한다.

```
하지만 React의 경우에는 살짝 다른 방식의 SPA를 사용한다

**네비게이터** 라는 놈이 서버에 데이터를 요청하여 원하는 데이터를 가져옴과 동시에 알맞은 템플릿을 이용하여

UI를 사용자에게 제공한다.

여기서 UI는 클릭, 마우스 조작, 키 입력과 같은 동작을 SPA에 전달한다.

## Hello World를 만들어 보자

환경은 아래의 url 을 기반으로 예제를 풀어나간다.

https://github.com/kimhaechang1/ReactStudy/blob/main/React%20%ED%95%99%EC%8A%B5%ED%99%98%EA%B2%BD%20%EA%B5%AC%EC%B6%95.md

먼저 index.html을 다음과 같이 작성한다.

```html
<!DOCTYPE html>
<html>
    <head>
        <script src = "node_modules/react/dist/react.js"></script>
        <script src = "node_modules/react-dom/dist/react-dom.js"></script>
    </head>
    <body>
        <div id = "content"></div>
        <script src = "js/script.js"></script>
    </body>
</html>
```
태그에는 라이브러리 파일을 추가 해준다.
  
우리가 필요한 라이브러리는 react이므로 관련 react.js와 react-dom.js 가 있다.
  
스크립트를 여러개 추가하고 싶다면 <script src = "js/JAVASCRIPT_FILE_NAME.js"></script> 를 더 넣으면 된다.
  
여기서 React 엘리먼트를 직접 <body>에 추가하지 않는 이유는 

다른 라이브러리나 <body>를 조작하는 브라우저 확장 프로그램과 충돌하는 것을 방지하기 위해서 이다.
  
이제 script.js를 작성해보자.
  
```js
var h1 = React.createElement('h1', null, 'Hello World!')
ReactDOM.render(
  h1,
  document.getElementById('content')
)
```
  
React 엘리먼트를 생성하려면 React.createElement( elementName, date, child )를 호출한다.
  
  * elementName : HTML 태그명을 문자열로 작성하거나, 직접 만든 컴포넌트 클래스 객체를 넘겨줄 수 있다.
  
  * data : 속성이나 상위 컴포넌트에 받는 값으로, null이나 {key : value} 와 같은 형태의 데이터 이다.
  
  * child : 자식 엘리먼트나 해당 태그가 가질 내용을 작성하는 텍스트 이다
 
위의 예제 코드는 h1태그가 달린 'Hello World'라는 요소를 React 엘리먼트로서 생성하고 변수 h1에 담는다.

그리고 실제 DOM에 렌더링 하기 위해서 ReactDOM.render(element, document.getElementById('id'))을 사용한다.
  
  * element : 실제 DOM에 렌더링 하기 위한 React 엘리먼트
  
  * document.getElementById('id') : 특정 id가 달린 요소를 DOM에서 찾아서 그 하위 에 노드를 추가한다.

***
## 끝마치며..
 
처음 프론트엔드에 발을 들이고 
  
그것의 시작을 React로 하려고 한것은 좋았으나

모르는 것이 산더미다.
  
무슨 DOM이니 diff 알고리즘이니, 생각보다 어려웠지만 하나하나 흐름을 타니 이해가 간다.
